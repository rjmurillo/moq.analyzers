# Moq1208: Returns() delegate type mismatch on async method setup

| Item     | Value |
| -------- | ----- |
| Enabled  | True  |
| Severity | Warning |
| CodeFix  | True |

---

## What this rule checks

In Moq, `.Setup()` defines what a mocked method should do when called.
`.Returns()` specifies the value the method gives back. For example:

```csharp
mock.Setup(x => x.GetName()).Returns(() => "Alice");
//   ^^^^^ "when GetName is called"     ^^^^^^^^^ "return Alice"
```

This rule fires when the function passed to `.Returns()` gives back a plain
value like `int` or `string`, but the mocked method is async and returns
`Task<int>` or `ValueTask<string>`. Moq requires the types to match exactly.

### Why this matters

The code compiles without errors, but the test fails at runtime with this
exception:

```
MockException: Invalid callback. Setup on method with return type 'Task<int>'
cannot invoke callback with return type 'int'.
```

This analyzer catches the mismatch at compile time so you don't have to debug
a failing test to find it.

### How this differs from Moq1206

[Moq1206](./Moq1206.md) flags `async` lambdas in `.Returns()`, such as
`Returns(async () => 42)`. Moq1208 flags regular (non-async) lambdas that
return the wrong type, such as `Returns(() => 42)` on a `Task<int>` method.

## Examples of patterns that are flagged by this analyzer

```csharp
public interface IService
{
    Task<int> GetValueAsync();       // Returns Task<int>
    Task<string> GetNameAsync();     // Returns Task<string>
    ValueTask<int> GetValueTaskAsync(); // Returns ValueTask<int>
}

var mock = new Mock<IService>();

// GetValueAsync returns Task<int>, but the lambda returns int.
mock.Setup(x => x.GetValueAsync()).Returns(() => 42); // Moq1208

// GetNameAsync returns Task<string>, but the lambda returns string.
mock.Setup(x => x.GetNameAsync()).Returns(() => "hello"); // Moq1208

// GetValueTaskAsync returns ValueTask<int>, but the lambda returns int.
mock.Setup(x => x.GetValueTaskAsync()).Returns(() => 42); // Moq1208
```

## Solution

### Option 1: Use ReturnsAsync (recommended)

`.ReturnsAsync()` wraps the value in `Task.FromResult()` for you. This is the
simplest fix and what the built-in code fix applies automatically.

```csharp
var mock = new Mock<IService>();

// Pass a plain value. Moq wraps it in Task.FromResult() internally.
mock.Setup(x => x.GetValueAsync()).ReturnsAsync(42);

// Or pass a lambda. Moq wraps the lambda's return value the same way.
mock.Setup(x => x.GetValueAsync()).ReturnsAsync(() => 42);
```

### Option 2: Wrap the value yourself

If you need more control, keep `.Returns()` and wrap the value explicitly.

```csharp
var mock = new Mock<IService>();

mock.Setup(x => x.GetValueAsync()).Returns(() => Task.FromResult(42));
mock.Setup(x => x.GetNameAsync()).Returns(() => Task.FromResult("hello"));
mock.Setup(x => x.GetValueTaskAsync()).Returns(() => new ValueTask<int>(42));
```

## Suppress a warning

If you just want to suppress a single violation, add preprocessor directives to
your source file to disable and then re-enable the rule.

```csharp
#pragma warning disable Moq1208
mock.Setup(x => x.GetValueAsync()).Returns(() => 42);
#pragma warning restore Moq1208
```

To disable the rule for a file, folder, or project, set its severity to `none`
in the
[configuration file](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/configuration-files).

```ini
[*.{cs,vb}]
dotnet_diagnostic.Moq1208.severity = none
```

For more information, see
[How to suppress code analysis warnings](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/suppress-warnings).
